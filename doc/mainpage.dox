// -*- lsst-c++ -*-

namespace lsst { namespace meas { namespace base {
/**
@mainpage lsst::meas::base;  redesigned support for measurement tasks and algorithm plugins

@section measBaseIntroduction Introduction to meas_base
The meas_base package is the new home of the source measurement framework, which was formerly part of
meas_algorithms.

The source measurement framework is a set of Python modules which allow measurements to be performed on
calibrated exposures. The framework assumes that a detection catalog has been prepared to identify the
objects to be measured.  The detection catalog may have been produced with a detection pass on the exposure
itself, but it might also be produced from other exposures, stacks, or even multiple exposures.
Deblending may or may not have been performed during the creation of the detection catalog.

The framework steps through the detection catalog and performs a set of measurements, object by object,
supplying each measurement plugin with the exposure and catalog information needed for its measurement.
The measurement results (values, errors, and flags) are then placed in an output catalog.

The measurement framework includes the following features:

 - @ref sfm.SingleFrameMeasurementTask "SingleFrameMeasurementTask", a subtask that measures after
   detection and deblending on the same frame (see @ref measBaseSFM).
 - Several tasks for forced photometry (see @ref measBaseForcedPhot).
 - Python Plugin base classes (@ref sfm.SingleFramePlugin "SingleFramePlugin",
   @ref forcedMeasurement.ForcedPlugin "ForcedPlugin") for single-frame and forced measurement.
 - Helper code to reduce boilerplate, standardize outputs, and make algorithm code easy to reuse when
   implementing new measurement algorithms.

@section measBaseSFM Single-Frame Measurement

The single frame measurement framework is used when all the information about the sources to be measured
comes from a single image, and hence those sources are detected (and possibly) deblended on that image
before measurement.  This image may be a coadd of other images, or even a difference of images - from
the perspective of the measurement framework there is essentially no difference between these cases (though
there may be important differences for particular measurement algorithms).

The high-level algorithm for single-frame measurement is:

 - The @ref sfm.SingleFrameMeasurementTask "SingleFrameMeasurementTask" is initialized (see also
   @ref sfm.SingleFrameMeasurementTask.__init__ "__init__").  This
   initializes all the configured algorithms, creating a schema for the outputs in the process.  After
   this stage, the schema cannot be modified and algorithm configuration can not longer be modified.

 - The @ref SingleFrameMeasurementTask.run "run()" method is called on each image to be processed, with a
   @ref lsst::afw::table::SourceCatalog "SourceCatalog" containing
   all the sources to be measured.  These sources must have Footprints (generated by
   @ref lsst.meas.algorithms.SourceDetectionTask "SourceDetectionTask"), and a schema that matches that
   constructed by the previous step.  The fields added to the schema during initialization will then be
   filled in by the measurement framework.

    * Before measuring any sources, the measurement framework replaces all sources in the catalog with
      noise (see @ref noiseReplacer.NoiseReplacer "NoiseReplacer"), using the
      @ref lsst::afw::detection::Footprint "Footprints" attached to the
      @ref lsst::afw::table::SourceCatalog "SourceCatalog" to define their boundaries.

    * We then loop over all "parent" sources in the catalog - both those that were not blended, and those
      that represent the pre-deblend combined state of blends.  For each parent, we loop again over all its
      children (if any), and for each of these, we re-insert the child source into the image (which, recall,
      currently contains only noise), call @ref sfm.SingleFramePlugin.measure() "measure()" on each of the
      plugins, and then replace the child source with noise again.  We the insert the parent source, and call
      @ref sfm.SingleFramePlugin.measure() "measure()" on all of the plugins.  Before replacing the parent
      with noise again, we then
      call @ref sfm.SingleFramePlugin.measureN() "measureN()" twice for each plugin: once with the list of
      all children, and once with a
      single-element list containing just the parent.  This ensures that each source (parent or child)
      is measured with both @ref sfm.SingleFramePlugin.measure() "measure()" and
      @ref sfm.SingleFramePlugin.measureN() "measureN()", with the former preceeding the latter.

Because measurement plugin algorithms are often dependent on each other (in particular, most measurements
require a centroid as an input), they must be run in a particular order, and we need a mechanism for passing
information between them.  The order is defined by the 'executionOrder' config parameter, which is defined
in the @ref base.BasePluginConfig "BasePluginConfig" class, and hence present for every plugin.  Generally,
these will remain at their
default values; it is the responsibility of a plugin implementor to ensure the default for that plugin
is appropriate relative to any plugins it depends on.  See BasePluginConfig.executionOrder for some
guidelines (it may be easiest to read the Python docstring directly; Doxygen garbles config documentation).

The mechanism for passing information between plugins is @ref lsst::afw::table::SourceTable "SourceTable's"
slot system (see lsst::afw::table::SlotDefinition), in which particular
measurements are given one of several predefined aliases (e.g. "slot_Centroid" -> "base_SdssCentroid"),
which are used to implement getters on @ref lsst::afw::table::SourceRecord "SourceRecord" (e.g.
@ref lsst::afw::table::SourceRecord::getCentroid() "getCentroid()".  The measurement framework's
configuration defines which measurements are assigned to each slot, and these slot measurements are
available to other plugins as soon as the plugin whose outputs are assigned to the slot are run.

All this means that algorithms that need a centroid as input should simply call
@ref lsst::afw::table::SourceRecord::getCentroid() "getCentroid()" on the
@ref lsst::afw::table::SourceRecord "SourceRecord" they're provided, and ensure that their @c executionOrder
is higher than that of centroid
algorithms.  Similarly, algorithms that want a shape should simply call
@ref afw::table::SourceRecord::getShape() "getShape()".  Things
are a bit trickier for centroid algorithms, which often need to be given an approximate centroid as an
input; these should be prepared to look at the @ref afw::detection::Peak "Peaks" attached to the
@ref afw::table::SourceRecord "SourceRecord's" @ref afw::detection::Footprint "Footprint" as an initial
value, as the slot centroid may not yet be valid.  For wrapped C++ Algorithms (see measBaseAlgorithmConcept),
this is handled automatically.

@section measBaseForcedPhot Forced Photometry

In forced photometry, an external "reference" catalog is used to constrain measurements on an image.  While
parts of the forced photometry framework could be with a reference catalog from virtually any source, a
complete system for loading the reference catalogs that correspond to the region of sky being measured
is only available when measurements from a coadd are used as the reference.

While essentially any measurement plugin can be run in forced mode, typically only photometric measurements
are scientifically useful (though centroids and shapes may be useful for quality metrics).  In fact, in
forced mode we typically configure pseudo-measurements to provide the shape and centroid slots, and it is
these --- rather than anything special about the forced measurement framework --- that constrains
measurements.  In particular, we generally use the
@ref plugins.ForcedTransformedCentroidPlugin "ForcedTransformedCentroidPlugin" and
@ref plugins.ForcedTransformedShapePlugin "ForcedTransformedShapePlugin"
to provide
the centroid and shape slots.  Rather than measure the centroid and shape on the image, these simply
transform the centroid and shape slots from the reference catalog to the appropriate coordinate system.
This ensures that measurements that use these slots to obtain positions and ellipses use the same quantities
used in generating the reference catalog.

The core of the forced measurement framework is
@ref forcedMeasurement.ForcedMeasurementTask "ForcedMeasurementTask" and
@ref forcedMeasurement.ForcedPlugin "ForcedPlugin", which
broadly parallel @ref sfm.SingleFrameMeasurementTask "SingleFrameMeasurementTask" and
@ref sfm.SingleFramePlugin "SingleFramePlugin".  The high-level algorithm is
essentially the same, but with the @ref afw.table.SourceCatalog "SourceCatalog" to be measured generated by
@ref forcedMeasurement.ForcedMeasurementTask.generateSources() "ForcedMeasurementTask.generateSources()"
from the
reference catalog, rather than provided by the user after running detection.  The corresponding reference
source and the @ref lsst::afw::image::Wcs "Wcs" objects that define the mapping between reference and
measurement coordinate systems are also provided to each plugin.

The fact that the sources to be measured are generated from the reference catalog means that the
@ref lsst::afw::detection::Footprint "Footprints"
attached to these sources must be transformed from the reference coordinate system to the measurement
coordinate system, and at present that operation turns
@ref lsst::afw::detection::HeavyFootprint "HeavyFootprints" into regular
@ref lsst::afw::detection::Footprint "Footprints".
@ref lsst::afw::detection::HeavyFootprint "HeavyFootprints" for child sources are necessary in order to
correctly replace neighboring children of the
same parent with noise prior to measurement (see @ref noiseReplacer.NoiseReplacer "NoiseReplacer"), and the
lack of these means that deblended
measurement in forced photometry is essentially broken, except for plugins that implement measureN() and
can hence correctly measure all children simultaneously without having to replace them with noise
individually.

In addition to the @ref forcedMeasurement.ForcedMeasurementTask "ForcedMeasurementTask" subtask and its
plugins, the forced measurement framework also
contains a pair of command-line driver tasks, @ref forcedPhotCcd.ForcedPhotCcdTask "ForcedPhotCcdTask"
and @ref forcedPhotCoadd.ForcedPhotCoaddTask "ForcedPhotCoaddTask".  These run
forced measurement on CCD-level images and coadd patch images, respectively, using the outputs of a
previous single-frame measurement run on coadds as the reference catalog in both cases.  These delegate
the work of loading (and as necessary, filtering and merging) the appropriate reference catalog for the
measurement image to a "references" subtask.  The interface for the reference subtask is defined by
@ref references.BaseReferencesTask "BaseReferencesTask", with the concrete implementation that utilizes
coadd processing outputs in
@ref references.CoaddSrcReferencesTask "CoaddSrcReferencesTask".  In general, to use a reference catalog
from another source, one should
implement a new references subtask, and reuse @ref forcedPhotCcd.ForcedPhotCcdTask "ForcedPhotCcdTask"
and/or @ref forcedPhotCoadd.ForcedPhotCoaddTask "ForcedPhotCoaddTask".  It
should only be necessary to replace these and use
@ref forcedMeasurement.ForcedMeasurementTask "ForcedMeasurementTask" directly if you need to run
forced photometry on data that isn't organized by the Butler or doesn't correspond to CCD- or patch-level
images.

@section measBaseImplementingNew Implementing New Plugins and Algorithms

The "Plugin" interfaces used directly by the measurement tasks are defined completely in Python, and are
rooted in the abstract base classes sfm.SingleFramePlugin and forcedImage.ForcedPlugin.  There are also
analogous C++ base classes, @ref SingleFrameAlgorithm and @ref ForcedAlgorithm, for plugins implemented
in C++, as well as @ref SimpleAlgorithm, a C++ base class for simple algorithms in which the same
implementation can be used for both single-frame and forced measurement.

For a SingleFramePlugin/SingleFrameAlgorithm:
 - Subclass sfm.SingleFramePlugin or SingleFrameAlgorithm
 - Implement an @c %__init__ method with the same signature as the base class, in which fields saved by the
   the Plugin should be added to the schema passed to @c %__init__, with keys saved as instance attributes
   for future use.  In C++, implement a constructor with one of the signatures supported by
   wrappers.wrapSingleFrameAlgorithm.
 - Reimplement @c measure() to perform the actual measurement and save the result in the measRecord argument.
 - Reimplement @c fail() unless the Plugin cannot fail (except for environment errors).
 - Reimplement @c measureN() if the Plugin supports measuring multiple sources simultaneously.
 - Register the Plugin with the config mechanism by calling e.g. @c SingleFramePlugin.registry.register()
   at module scope (so the registration happens at import-time).  Or, in C++, Swig the algorithm as you
   would any normal C++ class, and call wrappers.wrapSingleFrameAlgorithm to wrap and register the algorithm
   simultaneously.

For a ForcedPlugin/ForcedAlgorithm
 - Subclass forcedMeasurement.ForcedPlugin or ForcedAlgorithm
 - Implement an @c %__init__ method with the same signature as the base class, in which fields saved by the
   the Plugin should be added to the outputSchema of the schemaMapper passed to @c %__init__,
   with keys saved as instance attributes for future use.  In C++, implement a constructor with one of the
   signatures supported by by wrappers.wrapForcedAlgorithm.
 - Reimplement @c measure() (in Python) or @c measureForced (C++) to perform the actual measurement and save
   the result in the measRecord argument.  Note that the refRecord and refWcs are available during the
   measurement if needed.
 - Reimplement @c fail() unless the Plugin cannot fail (except for environment errors).
 - Reimplement @c measureN() (Python) or @c measureNForced() (C++) if the Plugin supports measuring multiple
   sources simultaneously.
 - Register the Plugin with the config mechanism by calling e.g. @c ForcedPlugin.registry.register()
   at module scope (so the registration happens at import-time).  Or, in C++, Swig the algorithm as you
   would any normal C++ class, and call wrappers.wrapSingleFrameAlgorithm to wrap and register the algorithm
   simultaneously.

In C++, one can also implement both interfaces at the same time using @ref SimpleAlgorithm (see that class for
more information).

@section measBaseErrorHandling Error Handling

When a Plugin (or the Algorithm it delegates to) raises any exception, the Task calling it will catch the
exception, and call the fail() method of the Plugin, which should cause the plugin to set one or more
flags in the output record.  If the exception is @ref MeasurementError, the Task will pass this
exception back to the fail() method, as @ref MeasurementError contains additional Plugin-specific information
indicating the kind of failure.  For most other exceptions, the Task will log the exception message
as a warning, and pass None as the exception to fail().  In this case, the Plugin should just set the
primary failure flag.  This is handled automatically by the @ref FlagHandler in Algorithm-based Plugins.
Certain exceptions (in particular, out-of-memory errors) are considered fatal and will always be propagated
up out of the Task.

Plugin/Algorithm code should endeavor to only throw @ref MeasurementError for known failure modes, unless the
problem is in the data and can always be fixed there before the measurement framework is invoked.  In other
words, we want warnings to appear in the logs only when there's a bug, whether that's in the processing
before the measurement framework or in a particular Plugin/Algorithm not knowing and documenting its own
failure modes.  This means that Plugin/Algorithm implementations should generally have a global try/catch
block that re-throwns lower-level exceptions corresponding to known failure modes as @ref MeasurementErrors.

@section measBaseFlagHandlerInPython Using a FlagHandler with Python Plugins

Review the SingleFramePlugin requirements for the measure() and fail() methods which a plugin must implement.
When the plugin detects an error, it should raise a MeasurementError exception, which triggers a call to fail().
A FlagHandler is a convenient way for a plugin to define error flags for different errors, and to set those
error flags in fail() method when they occur.

<B>
How to Define a FlagHandler in Python:
</B>

The meas_base plugins implemented in C++ use lsst::meas::base::FlagHander to handle measurement exceptions.
In Python, measurement plugins may use the addFlagHandler decorator to create an an instance of this class.
This section describes how to use the addFlagHandler decorator and the FlagHandler.

First examine the code testFlagHandler.py in the meas_base tests directory. This unit test defines a
plugin written in Python which illustrates several useful techniques about using the FlagHander.
Note first the line decorating the class definition, which reads like this:

@code{.py}
@addFlagHandler(("flag", "General Failure error"),
                ("flag_containsNan","Measurement area contains a nan"),
                ("flag_edge", "Measurement area over edge"))
class PythonPlugin(SingleFramePlugin):

    ConfigClass = PythonPluginConfig

    def __init__(self, config, name, schema, metadata):
        ...

    def measure(self, measRecord, exposure):
        ...

    def fail(self, measRecord, error=None):
        ...
@endcode
This class decorator modifies your plugin class to add a <B>flagHandler</B> attribute, an instance of
lsst.meas.base.FlagHandler. This instance defines error flags for your plugin:

- a general failure flag which indicates that something has gone wrong during measure().
- a specific failure flag which indicates a source which contain nans.
- a specific failure flag which indicates that the source is too close to the edge to be measured.

The FlagHander is also used to implement your fail() method in Python. Recall that you must implement
this method in your plugin class if your method can fail.

The following addition to your class will correctly implement the error handling:

@code{.py}
    def fail(self, measRecord, error=None):
        if error is None:
            self.flagHandler.handleFailure(measRecord)
        else:
            self.flagHandler.handleFailure(measRecord, error.cpp)
@endcode

When the error is one which your plugin code expects, your code will raise a MeasurementError exception.
The error is sent to the fail() method in the "error" argument. The error will indicate which flag should
be set in addition to the general failure flag. If the error argument is not supplied, only the general
failure flag will be set.

<B>
Using the ErrEnum to raise a MeasurementError exception:
</B>

In addition to the flagHander attribute, the addFlagHandler class decorator also adds an "ErrEnum"
member to your plugin.  This enumeration provides a unique name for each error type. For example,
to raise a MeasurementError when the measured source is too near the edge of the exposure:

@code{.py}
        #   If the measurement box falls outside the exposure, raise the edge MeasurementError
        if not exposure.getBBox().contains(bbox):
            raise MeasurementError(self.flagHandler.getDefinition(self.ErrEnum.flag_edge).doc,
                PythonPlugin.ErrEnum.flag_edge)
@endcode

The PythonPlugin measures the flux inside a square box drawn around the center
of a detected source.  This aperture is "size" pixels square, where "size" is a configurable value.
The requested aperture could lie partly outside the exposure being measured, which would constitute
an error condition for this plugin. When the MeasurementError is raised, both the general flag 
and the flag_edge flag will be set to True.

<B>
Using the SafeCentroidExtractor:
</B>

The PythonPlugin example also demonstrates the use of the SafeCentroidExtractor from Python.
The SafeCentroidExtractor is used by many of the C++ algorithms to fetch a value for the centroid of
the source, even if the centroid algorithm has failed on this source. Since the source was detected,
it will always have a detection Footprint which can be used as a fallback to locate the center of
the object.

Define the SafeCentroidExtractor in the initialization of your plugin, like this:

@code{.py}
    def __init__(self, config, name, schema, metadata):
        SingleFramePlugin.__init__(self, config, name, schema, metadata)
        self.centroidExtractor = lsst.meas.base.SafeCentroidExtractor(schema, name)
@endcode

Then use centroidExtractor to fetch the centroid:

@code{.py}
center = self.centroidExtractor(measRecord, self.flagHandler)
@endcode

The SafeCentroidExtractor will first try to read the centroid from the centroid slot.  But if the
failure flag on the centroid slot has been set to "True", it will try to use the detection footprint
to determine the centroid. This might potentially allow the plugin to complete its measure() method
if the centroid provided is "good enough".

To indicate at the same time that something has gone wrong, the general flag will automatically get
set on this source.  The SafeCentroidExtractor will also create a flag called "flag_badCentroid"
which points to the centroid slot failure flag, and can be used to distinguish records where
the failure flag was been set because the centroid slot measurement was bad.
*/
}}} // namespace lsst::meas::base
